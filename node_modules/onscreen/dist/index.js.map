{"version":3,"sources":["helpers/observe-dom.ts","methods/attach.ts","helpers/in-viewport.ts","helpers/in-container.ts","helpers/scroll-handler.ts","methods/debounced-scroll.ts","methods/destroy.ts","methods/off.ts","methods/on.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["/**\n * Observes DOM mutations and runs a callback function when\n * detecting one.\n *\n * @param {node} obj The DOM node you want to observe\n * @param {function} callback The callback function you want to call\n * @return {MutationObserver} obs The mutation observer instance used to track DOM mutations\n */\nfunction observeDOM(obj, callback) {\n    const MutationObserver = window.MutationObserver;\n\n    /* istanbul ignore else */\n    if (MutationObserver) {\n        const obs = new MutationObserver(callback);\n\n        obs.observe(obj, {\n            childList: true,\n            subtree: true\n        });\n\n        return obs;\n    }\n\n    obj.addEventListener('DOMNodeInserted', callback, false);\n    obj.addEventListener('DOMNodeRemoved', callback, false);\n\n    return null;\n}\n\nexport default observeDOM;\n","import observeDOM from '../helpers/observe-dom';\n\n/**\n * Attaches the scroll event handler\n *\n * @return {void}\n */\nfunction attach() {\n    const container = this.options.container;\n\n    if (container instanceof HTMLElement) {\n        const style = window.getComputedStyle(container);\n\n        if (style.position === 'static') {\n            container.style.position = 'relative';\n        }\n    }\n\n    this._observer = observeDOM(document.querySelector('body'), () => {\n        Object.keys(this.trackedElements).forEach((element) => {\n            this.on('enter', element);\n            this.on('leave', element);\n        });\n    });\n\n    container.addEventListener('scroll', this._scroll, { passive: true });\n    window.addEventListener('resize', this._scroll, { passive: true });\n    this._scroll();\n    this.attached = true;\n}\n\nexport default attach;\n","/**\n * Checks an element's position in respect to the viewport\n * and determines wether it's inside the viewport.\n *\n * @param {node} element The DOM node you want to check\n * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n */\nfunction inViewport(element: HTMLElement, options: Options) {\n    if (!element) {\n        throw new Error('You should specify the element you want to test');\n    }\n\n    if (typeof element === 'string') {\n        element = document.querySelector(element);\n    }\n\n    const elRect = element.getBoundingClientRect();\n\n    return (\n        // Check bottom boundary\n        elRect.bottom - options.tolerance > 0 &&\n\n        // Check right boundary\n        elRect.right - options.tolerance > 0 &&\n\n        // Check left boundary\n        elRect.left + options.tolerance < (window.innerWidth ||\n        document.documentElement.clientWidth) &&\n\n        // Check top boundary\n        elRect.top + options.tolerance < (window.innerHeight ||\n        document.documentElement.clientHeight)\n    );\n}\n\nexport default inViewport;\n","/**\n * Checks an element's position in respect to a HTMLElement\n * and determines wether it's within its boundaries.\n *\n * @param {node} element The DOM node you want to check\n * @return {boolean} A boolean value that indicates wether is on or off the container.\n */\nfunction inContainer (element: HTMLElement, options : Options) {\n    if (!element) {\n        throw new Error('You should specify the element you want to test');\n    }\n\n    if (typeof element === 'string') {\n        element = document.querySelector(element);\n    }\n\n    if (typeof options === 'string') {\n        options = {\n            tolerance: 0,\n            container: document.querySelector(options)\n        };\n    }\n\n    if (typeof options.container === 'string') {\n        options.container = document.querySelector(options.container);\n    }\n\n    if (options instanceof HTMLElement) {\n        options = {\n            tolerance: 0,\n            container: options\n        };\n    }\n\n    if (!options.container) {\n        throw new Error('You should specify a container element');\n    }\n\n    const containerRect = options.container.getBoundingClientRect();\n\n    return (\n        // // Check bottom boundary\n        (element.offsetTop + element.clientHeight) - options.tolerance >\n        options.container.scrollTop &&\n\n        // Check right boundary\n        (element.offsetLeft + element.clientWidth) - options.tolerance >\n        options.container.scrollLeft &&\n\n        // Check left boundary\n        element.offsetLeft + options.tolerance <\n        containerRect.width + options.container.scrollLeft &&\n\n        // // Check top boundary\n        element.offsetTop + options.tolerance <\n        containerRect.height + options.container.scrollTop\n    );\n}\n\nexport default inContainer;\n","import inViewport from './in-viewport';\nimport inContainer from './in-container';\n\n// TODO: Refactor this so it can be easily tested\n/* istanbul ignore next */\nfunction eventHandler(trackedElements = {}, options = { container: window, tolerance: 0 }) {\n    const selectors = Object.keys(trackedElements);\n    let testVisibility;\n\n    if (!selectors.length) return;\n\n    if (options.container === window) {\n        testVisibility = inViewport;\n    } else {\n        testVisibility = inContainer;\n    }\n\n    selectors.forEach((selector) => {\n        trackedElements[selector].nodes.forEach((item) => {\n            if (testVisibility(item.node, options)) {\n                item.wasVisible = item.isVisible;\n                item.isVisible = true;\n            } else {\n                item.wasVisible = item.isVisible;\n                item.isVisible = false;\n            }\n            if (item.isVisible === true && item.wasVisible === false) {\n                if (!trackedElements[selector].enter) return;\n\n                Object.keys(trackedElements[selector].enter).forEach((callback) => {\n                    if (typeof trackedElements[selector].enter[callback] === 'function') {\n                        trackedElements[selector].enter[callback](item.node, 'enter');\n                    }\n                });\n            }\n            if (item.isVisible === false && item.wasVisible === true) {\n                if (!trackedElements[selector].leave) return;\n\n                Object.keys(trackedElements[selector].leave).forEach((callback) => {\n                    if (typeof trackedElements[selector].leave[callback] === 'function') {\n                        trackedElements[selector].leave[callback](item.node, 'leave');\n                    }\n                });\n            }\n        });\n    });\n}\n\nexport default eventHandler;\n","import scrollHandler from '../helpers/scroll-handler';\n\n/**\n * Debounces the scroll event to avoid performance issues\n *\n * @return {void}\n */\nfunction debouncedScroll() {\n    let timeout;\n\n    return () => {\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            scrollHandler(this.trackedElements, this.options);\n        }, this.options.debounce);\n    };\n}\n\nexport default debouncedScroll;\n","/**\n * Removes the scroll event handler\n *\n * @return {void}\n */\nfunction destroy() {\n    if (this._observer instanceof MutationObserver) {\n        this._observer.disconnect();\n    }\n\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n}\n\nexport default destroy;\n","/**\n * Stops tracking elements matching a CSS selector. If a selector has no\n * callbacks it gets removed.\n *\n * @param {string} event The event you want to stop tracking (enter or leave)\n * @param {string} selector The CSS selector you want to stop tracking\n * @return {void}\n */\nfunction off(event, selector, handler) {\n    const enterCallbacks = Object.keys(this.trackedElements[selector].enter || {});\n    const leaveCallbacks = Object.keys(this.trackedElements[selector].leave || {});\n\n    if ({}.hasOwnProperty.call(this.trackedElements, selector)) {\n        if (handler) {\n            if (this.trackedElements[selector][event]) {\n                const callbackName = (typeof handler === 'function') ? handler.name : handler;\n                delete this.trackedElements[selector][event][callbackName];\n            }\n        } else {\n            delete this.trackedElements[selector][event];\n        }\n    }\n\n    if (!enterCallbacks.length && !leaveCallbacks.length) {\n        delete this.trackedElements[selector];\n    }\n}\n\nexport default off;\n","/**\n * Starts tracking elements matching a CSS selector\n *\n * @param {string} event The event you want to track (enter or leave)\n * @param {string} selector The element you want to track\n * @param {function} callback The callback function to handle the event\n * @return {void}\n */\nfunction on(event, selector, callback) {\n    const allowed = ['enter', 'leave'];\n\n    if (!event) throw new Error('No event given. Choose either enter or leave');\n    if (!selector) throw new Error('No selector to track');\n    if (allowed.indexOf(event) < 0) throw new Error(`${event} event is not supported`);\n\n    if (!{}.hasOwnProperty.call(this.trackedElements, selector)) {\n        this.trackedElements[selector] = {};\n    }\n\n    this.trackedElements[selector].nodes = [];\n\n    for (let i = 0, elems = document.querySelectorAll(selector); i < elems.length; i++) {\n        const item = {\n            isVisible: false,\n            wasVisible: false,\n            node: elems[i]\n        };\n\n        this.trackedElements[selector].nodes.push(item);\n    }\n\n    if (typeof callback === 'function') {\n        if (!this.trackedElements[selector][event]) {\n            this.trackedElements[selector][event] = {};\n        }\n\n        this.trackedElements[selector][event][(callback.name || 'anonymous')] = callback;\n    }\n}\n\nexport default on;\n","// Methods\nimport attach from './methods/attach';\nimport debouncedScroll from './methods/debounced-scroll';\nimport destroy from './methods/destroy';\nimport off from './methods/off';\nimport on from './methods/on';\n\n// Helpers\nimport inViewport from './helpers/in-viewport';\n\n/**\n * Detects wether DOM nodes enter or leave the viewport\n *\n * @constructor\n * @param {object} options The configuration object\n */\nfunction OnScreen (options: Options = { tolerance: 0, debounce: 100, container: window }) {\n    this.options = {};\n    this.trackedElements = {};\n\n    Object.defineProperties(this.options, {\n        container: {\n            configurable: false,\n            enumerable: false,\n            get() {\n                let container;\n\n                if (typeof options.container === 'string') {\n                    container = document.querySelector(options.container);\n                } else if (options.container instanceof HTMLElement) {\n                    container = options.container;\n                }\n\n                return container || window;\n            },\n            set(value) {\n                options.container = value;\n            }\n        },\n        debounce: {\n            get() {\n                return options.debounce || 100;\n            },\n            set(value) {\n                options.debounce = value;\n            }\n        },\n        tolerance: {\n            get() {\n                return options.tolerance || 0;\n            },\n            set(value) {\n                options.tolerance = value;\n            }\n        }\n    });\n\n    Object.defineProperty(this, '_scroll', {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: this._debouncedScroll.call(this)\n    });\n\n    this.attach();\n}\n\nObject.defineProperties(OnScreen.prototype, {\n    _debouncedScroll: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: debouncedScroll\n    },\n    attach: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: attach\n    },\n    destroy: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: destroy\n    },\n    off: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: off\n    },\n    on: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: on\n    }\n});\n\nOnScreen.check = inViewport;\n\nexport default OnScreen;\n"]}